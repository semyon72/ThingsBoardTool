<?php

namespace SoftDeviceActorBundle\Repository;

use Doctrine\ORM\Query\ResultSetMappingBuilder;
use SoftDeviceActorBundle\Entity\TBSoftDevices;
use SoftDeviceActorBundle\Entity\TBSoftDevicesScheduledTasks;
use SoftDeviceActorBundle\Utils\RandomSequenceGenerator;

/**
 * TBSoftDevicesScheduledTasksRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TBSoftDevicesScheduledTasksRepository extends \Doctrine\ORM\EntityRepository
{
    
    /**
     * 
     * @return array Of TBSoftDevicesScheduledTasks instances
     */
    public function getActiveTasks(){
        
        $em= $this->getEntityManager();
        $metaInfo = $this->getClassMetadata();
        
        $sql= 'SELECT `st`.* '."\r\n"
            . 'FROM `'.$metaInfo->getTableName().'` `st`'."\r\n"
            . 'WHERE '."\r\n"
            . ' ROUND( IFNULL(`st`.`value_limit`,0) - IFNULL(`st`.`value_used`,0), 4 ) > 0.0  ';
        
        $rsm = new ResultSetMappingBuilder($em);
        $rsm->addRootEntityFromClassMetadata($metaInfo->getName(), 'st');
        
        return($em->createNativeQuery($sql, $rsm)->getResult());
    }

    /**
     * 
     * @param SoftDeviceActorBundle\Entity\TBSoftDevices $device
     * @param \DateTime $onDay
     * @return SoftDeviceActorBundle\Entity\TBSoftDevicesScheduledTasks 
     * @throws \Exception
     */
    public function getTaskFor( TBSoftDevices $device, \DateTime $onDay = null ){
        $result = null;

        if (is_null($onDay)) $onDay = new \DateTime();
        $onDayTS = intval($onDay->getTimestamp()/60/60/24);
        
        $tbId = $device->getTbId();
        $valueName = $device->getValueName();
        
        $foundRows = $this->findBy( array('tb_id'=>$tbId, 'value_name'=>$valueName, 'day_ts'=>$onDayTS) );
        $numRows = count($foundRows);
        if ( $numRows > 0){
            if ( $numRows === 1) $result = $foundRows[0];
              else throw new \Exception ('Table \''.$this->getClassMetadata()->getTableName().'\' contains more than one row for task ['.$tbId.'::'.$valueName.'] per day \''.strval($onDay).'\'' );
        }
        
        return($result);
    }
    
    /**
     * 
     * @param TBSoftDevices $device
     * @param float $value
     * @param \DateTime $onDay By default today
     * @return TBSoftDevicesScheduledTasks Returns the new instance or that exists in base for matching expression 
     */
    public function createTaskFor( TBSoftDevices $device, $value, \DateTime $onDay = null ){
        
        $shedTask = $this->getTaskFor($device,$onDay);
        
        if(is_null($onDay)) $onDay = new \DateTime();
        $onDayTS = intval($onDay->getTimestamp()/60/60/24);
        
        if (is_null($shedTask) ){
            $shedTask = new TBSoftDevicesScheduledTasks();
            $shedTask->setDayTs($onDayTS)
                    ->setTbId($device->getTbId())
                    ->setValueName($device->getValueName())
                    ->setValueLimit(round((float)$value,4))
                    ->setValueUsed(0.0)
                    ->setSchedule($this->createSchedule( $shedTask->getValueLimit() ));
            $this->getEntityManager()->persist($shedTask);
            $this->getEntityManager()->flush(); 
        }
        
        return($shedTask);
    }
    
    /**
     * 
     * @param float $value 
     * @return string json_encoded array of splitted in more small parts of original value. 
     * array have structure like 
     * array( 'spl_object_hash(of value)'=>(object)array('value'=>$value, 'isProcessed'=>false), .... 
     *        'spl_object_hash(of value)'=>(object)array('value'=>$value, 'isProcessed'=>false) );
     * 
     */
    protected function createSchedule($value){
        $result = '';
        
        $value = round(floatval($value),4);
        if ( $value - 0.0001 === 0 ) $value = 0.0;
        if ( $value > 0){
            $randSeqGenerator= new RandomSequenceGenerator($value,0.23);
            $seq = $randSeqGenerator->getSequence();
            foreach ($seq as $randVal){
                $arrResult[md5(strval(mt_rand()).microtime().strval($randVal))] = array('value'=>$randVal, 'isProcessed'=>false);
            }
            $result = json_encode($arrResult);
        }
        
        return($result);
    }
    
    /**
     * Returns stdClass:ScheduledTask => $scheduledTask // SoftDeviceActorBundle\Entity\TBSoftDevicesScheduledTasks
     * and stdClass:Schedule => $scheduleArr // array like  [ 'hash'=> array('value'=>$value, 'isProcessed'=>false), .... 'hash'=> array('value'=>$value, 'isProcessed'=>false)];
     * 
     * @param integer $id
     * @return object stdClass:ScheduledTask => Entity\TBSoftDevicesScheduledTasks and stdClass:Schedule => Array of schedule items.
     * @throws \Exception
     */
    public function getSchedule($id){
        $result= null;
        $scheduledTask = $this->find($id);
        if ( !is_null($scheduledTask) ){
            $commonPartOfErrorMessage = 'Can\'t close item of schedule for scheduled task ['
                        .$scheduledTask->getTbId().':'.$scheduledTask->getValueName().']';
            $scheduleStr = $scheduledTask->getSchedule();
            if ( empty($scheduleStr) ) throw new \Exception ($commonPartOfErrorMessage.' because schedule is empty.');
            $scheduleArr = json_decode($scheduleStr,true);
            if( is_array($scheduleArr) && count($scheduleArr) > 0 ){
                $result = (object) array('ScheduledTask'=>$scheduledTask, 'Schedule'=>$scheduleArr);
            } else throw new \Exception ($commonPartOfErrorMessage.' because array of schedule\'s items is empty.');
        } else throw new \Exception ('Can\'t find scheduled task for [id = '."$id".']');
        
        return($result);
    }
    
    /**
     * Close schedule's item
     * 
     * @param integer $id Primary key of scheduled task.
     * @param string $itemKey Key of item in schedule. 
     * @return TBSoftDevicesScheduledTasksRepository This object.
     * @throws \Exception
     */
    public function closeScheduleItem($id, $itemKey){
        
        $scheduleInfo = $this->getSchedule($id);
        if( !is_null($scheduleInfo) ){
            $scheduleArr = $scheduleInfo->Schedule;
            $scheduledTask = $scheduleInfo->ScheduledTask;
            $commonPartOfErrorMessage = 'Can\'t close item of schedule for scheduled task ['
                        .$scheduledTask->getTbId().':'.$scheduledTask->getValueName().']';

            if ( !isset($scheduleArr["$itemKey"]) ) throw new \Exception ($commonPartOfErrorMessage.' because array of schedule\'s items doesn\'t contains item\'s key ['."$itemKey".']');
            else {
                if( $scheduleArr["$itemKey"]['isProcessed'] === false){
                    $scheduledTask->setValueUsed( $scheduledTask->getValueUsed() + $scheduleArr["$itemKey"]['value'] );
                    $scheduleArr["$itemKey"]['isProcessed'] = true;
                    $scheduledTask->setSchedule(json_encode($scheduleArr));

                    $em= $this->getEntityManager();
                    $em->persist($scheduledTask);
                    $em->flush($scheduledTask);
                } else throw new \Exception ($commonPartOfErrorMessage.' because this item ['."$itemKey".'] is closed yet.');
            }
        }
        
        return($this);
    }
    
    /**
     * 
     * @param type $id
     * @return stdClass stdClass:ScheduledTask => Entity\TBSoftDevicesScheduledTasks,
     * stdClass:Schedule => Array of schedule items.
     * stdClass:ScheduleItemKey => Key that proposed for updating
     */
    public function getNextScheduleItem($id){
        $scheduleInfo = $this->getSchedule($id);
        
        if( !is_null($scheduleInfo) ){
            $scheduleInfo->ScheduleItemKey = '';
            $scheduleArr = $scheduleInfo->Schedule;
            
            foreach($scheduleArr as $itemKey=>$item){
                if ($item['isProcessed'] === false) {
                    $scheduleInfo->ScheduleItemKey = $itemKey;
                    break;
                }
            }

        }
        
        return($scheduleInfo);
    }
    
    
}
