<?php

namespace TBStatBundle\Repository\MySQL;

use TBStatBundle\Tools\TBTelemetryTools;
use TBStatBundle\Repository\TBStatRepositoryBase;
use TBStatBundle\Entity\MySQL;

/**
 * TBTelemetryStatAvgRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class TBTelemetryStatAvgRepository extends TBStatRepositoryBase
{
    
    /**
     * Returns rows that show information about averaged data by 
     * ThingBoard device identifier and it name of value. In common case
     * ThingBoard device identifier will have one name of value but some devices
     * will support two or more device value. For example as possible case this is
     * water meter for hot water. In this case Device will have volume of used water
     * and temperature of it (averaged). 
     * 
     * @param string $tbDevId
     * @param integer $day Day from begin epoch that will in middle of $totalRows
     * that will gotten for calculation of average data.
     * @param integer $totalRows Will used $totalRows + 1 for calculation of average
     * data if half values of $totalRows more and less that $day are exists. 
     * @return array
     */
    public function getAverageValue($tbDevId, $day = -1, $totalRows = 10 ){
        $day = (int) $day;
        if ($day < 0 ) $day = TBTelemetryTools::getNowDay();
        $totalRows = (int)$totalRows;
       
        $sql = 'SELECT `au`.`tbId`, `au`.`valueName`, AVG(`au`.`valueAvg`)'."\r\n".
'FROM ('."\r\n".
'(SELECT `id`, `day_ts` AS `dayTs`, `tb_id` AS `tbId`, `tb_name` AS `tbName`, `value_name` AS `valueName`, `value_avg` AS `valueAvg`'."\r\n".
'FROM `tb_telemetry_stat_avg`'."\r\n".
'WHERE `tb_id` = :TbDevId'."\r\n".
' AND `day_ts` >= :ReqStatDay '."\r\n".
'ORDER BY `day_ts` ASC'."\r\n".
'LIMIT '. strval(intval($totalRows/2)+1) .' )'."\r\n".
'UNION '."\r\n".
'(SELECT `id`, `day_ts` AS `dayTs`, `tb_id` AS `tbId`, `tb_name` AS `tbName`, `value_name` AS `valueName`, `value_avg` AS `valueAvg`'."\r\n".
'FROM `tb_telemetry_stat_avg`'."\r\n".
'WHERE `tb_id` = :TbDevId '."\r\n".
' AND `day_ts` < :ReqStatDay'."\r\n".
'ORDER BY `day_ts` DESC'."\r\n".
'LIMIT '.strval(intval($totalRows/2)).')'."\r\n".
') `au`'."\r\n".
'Group by `au`.`tbId`, `au`.`valueName`';
        
        $result = $this->connection->fetchAll($sql, array(':TbDevId'=>$tbDevId,':ReqStatDay'=>$day));
        return($result);
    }
 
    
    public function getNearestAverageValue($tbDevId, $tbDevValueName = '', $day = -1, $oneNearestRow = true ){
        $result= array();
        
        $day = (int) $day;
        if ($day < 0 ) $day = TBTelemetryTools::getNowDay();
        
        $date = date('m', TBTelemetryTools::getDayToTS($day));

        $сonstSQLpart = 'SELECT `id`, `day_ts` AS `dayTs`, `tb_id` AS `tbId`, `tb_name` AS `tbName`, `value_name` AS `valueName`, `value_avg` AS `valueAvg`'."\r\n".
'FROM `tb_telemetry_stat_avg`'."\r\n".
'WHERE `tb_id` = :TbDevId'."\r\n".( !is_null($tbDevValueName) && $tbDevValueName !== '' ? ' AND `value_name` = :TbDevValueName '."\r\n" : '').
'{VARY_PART}'.
'LIMIT 1 ';
        
        $params = array(':TbDevId'=>$tbDevId,':ReqStatDay'=>$day, ':TbDevValueName'=> "$tbDevValueName");
        
        $sql = str_replace('{VARY_PART}', ' AND `day_ts` >= :ReqStatDay '."\r\n".'ORDER BY `day_ts` ASC'."\r\n", $сonstSQLpart);
        $nearBelowRow = $this->connection->fetchAll($sql, $params);
        
        $sql = str_replace('{VARY_PART}', ' AND `day_ts` <= :ReqStatDay '."\r\n".'ORDER BY `day_ts` DESC'."\r\n", $сonstSQLpart);
        $nearAboveRow = $this->connection->fetchAll($sql, $params);
        
        if ( $oneNearestRow !== true){
            $result = array_merge($nearAboveRow, $nearBelowRow);
        } else {
            $dayBelow = 0;
            if(count($nearBelowRow) > 0) $dayBelow = (int) $nearBelowRow[0]['dayTs'];

            $dayAbove = 0;
            if(count($dayAbove) > 0) $dayAbove = (int) $nearAboveRow[0]['dayTs'];
            
            if($dayAbove !==  $dayBelow || ($dayAbove ===  $dayBelow && $dayAbove > 0) ) {
                $result = $nearAboveRow;
                if ( abs($day - $dayAbove) > abs($day - $dayBelow) ) $result = $nearBelowRow;
            }
        }        
        return($result);
    }
    
    /**
     * 
     * @param string $tbDeviceID
     * @param string $deviceValueName
     * @param \DateTime $onDate On this date will calculated the average value.
     * @param string $subtractDateIntervalStr Number of day | month | year that 
     * precede to $onDate date and will used for calculation the average value.
     * Only year-month-day part of $onDate date is using. 
     */
    public function update($tbDeviceID='', $deviceValueName='', \DateTime $onDate = null, $subtractDateIntervalStr = '1 month') {
        
        if ( is_null($onDate) ) $onDate = new \DateTime();
        $startDate = clone($onDate);
        $startDate->sub(\DateInterval::createFromDateString($subtractDateIntervalStr));
        
        $onDateTs = TBTelemetryTools::getDayWisely($onDate);
        
        $tbStatRep = $this->getEntityManager()->getRepository(MySQL\TBTelemetryStat::class);
        $resStatInfo = $tbStatRep->getAverageStatData($tbDeviceID,$deviceValueName,$startDate,$onDate);
        
        //'tb_id', 'tb_name', 'value_name','last_val','avg_val','standart_deviation';
        $settersToFieldNames = array(
            'setDayTs'=>function($activeRow, $currentFieldName = 'day_ts') use ($onDateTs) { return $onDateTs; },
            'setTbId'=>'tb_id','setTbName'=>'tb_name',
            'setValueName'=>'value_name','setValueAvg'=>'avg_val'
        );
        
        $this->_updateARfromArray($resStatInfo, MySQL\TBTelemetryStatAvg::class,function($sourceRow) use ($onDateTs){
            return(array(
                'day_ts'=>$onDateTs, 'tb_id' => $sourceRow['tb_id'],
                'tb_name'=>$sourceRow['tb_name'], 'value_name' => $sourceRow['value_name'],
                )
            );
        },$settersToFieldNames);

    }


    /**
     * Always calculate average value in range 1 month 
     * (default value for TBTelemetryStatAvgRepository::update(....,$subtractDateIntervalStr = '1 month') function)
     * preceded $onDate value. But this calculation will doing $onDate at one day less each time the $numDays times.
     * 
     * @param string $tbDeviceID
     * @param string $deviceValueName
     * @param \DateTime $onDate This value used only in day part of \DateTime object 
     * @param int $numDays Number of days that must precede before $upDate one by one.
     */
    public function updateNumDaysBefore($tbDeviceID='', $deviceValueName='', \DateTime $onDate = null, $numDays = 0) {
        if ($numDays === 0) $numDays = 7;
        if ( is_null($onDate) ) $onDate = new \DateTime();
        for ($subDay = 0 ; $subDay < $numDays; $numDays--){
            $this->update($tbDeviceID, $deviceValueName, $onDate);
            $onDate->sub(\DateInterval::createFromDateString('1 day'));
        }
        
    }
    
}
